<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Maximum Flow | Maksadbek’s blog</title>
<meta name="generator" content="Jekyll v3.6.3" />
<meta property="og:title" content="Maximum Flow" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is a draft. Contains lots of mistakes. Stop here and close the tab. No kidding." />
<meta property="og:description" content="This is a draft. Contains lots of mistakes. Stop here and close the tab. No kidding." />
<link rel="canonical" href="http://maksadbek.github.io/algorithms/2019/04/23/maximum-flow.html" />
<meta property="og:url" content="http://maksadbek.github.io/algorithms/2019/04/23/maximum-flow.html" />
<meta property="og:site_name" content="Maksadbek’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-23T14:46:40+03:00" />
<script type="application/ld+json">
{"url":"http://maksadbek.github.io/algorithms/2019/04/23/maximum-flow.html","headline":"Maximum Flow","dateModified":"2019-04-23T14:46:40+03:00","datePublished":"2019-04-23T14:46:40+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maksadbek.github.io/algorithms/2019/04/23/maximum-flow.html"},"description":"This is a draft. Contains lots of mistakes. Stop here and close the tab. No kidding.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://maksadbek.github.io/feed.xml" title="Maksadbek's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Maksadbek&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/resume/">Resume</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ] });"></script>



<blockquote>
  <p>This is a draft. Contains lots of mistakes. Stop here and close the tab. No kidding.</p>
</blockquote>

<h2 id="maximum-flow-problem-with-ford-fulkerson-and-edmonds-karp-algorithms">Maximum-flow problem with Ford-Fulkerson and Edmonds-Karp algorithms</h2>

<p>TODO: improve
This blog post explains hard mathematical proofs of max-flow min cut theorem and digest of my readings on CRLS.</p>

<h3 id="flow-and-flow-networks">Flow and flow networks</h3>

<p><strong>Flow network</strong> is a graph $G = (V, E)$ with the following features:</p>
<ul>
  <li>Each edge has a nonnegative capacity - $c_e$</li>
  <li>The is a single node considered as <em>source</em> of the flow</li>
  <li>The is a single node considered as <em>sink</em> that absorbs the flow.</li>
  <li>No edge enters the <em>source</em> and no edges leaves <em>sink</em></li>
  <li>There is at least one edge incident to each node.</li>
</ul>

<p>The nodes other than <em>source</em> and <em>sink</em> are called <em>internal</em> nodes.</p>

<p><strong>Flow</strong> is a function $f$ that maps each edge $e$ to a nonnegative real number: $f: e \to r$; the value of $f(e)$ represents the amount of flow carried by edge $e$. a flow $f$ must satisfy the following two properties:</p>

<ol>
  <li>
    <p><strong>Capacity conditions</strong> - for each $e \in e$, we have $ 0&lt;= f(e) &lt;= c_e$. the flow on edge $e$ cannot exceed the capacity of edge. i.e: flow in equals flow out.</p>
  </li>
  <li>
    <p><strong>Conservation conditions</strong> - for each nodes $v$ other than $s$ and $t$, we have $ \sum_{v \in v} f(v, u) = \sum_{v \in v} f(u, v) $. The node $v$ can omit as much flow as incoming from $u$.</p>
  </li>
</ol>

<p>The flow from $u$ to $v$ is a nonnegative and defined as $f(u, v)$ and value of a flow $f$ is denoted with $\vert f \vert$ and defined as: $\vert f \vert = \sum_{v \in v} f(s, v) - \sum_{v \in v} f(v, s)$. That is, the total from out of source to adjacent vertexes minus the total flow from adjacent vertexes into source. yes, this can happen, where source node has both incoming and outgoing edges.</p>

<p>Even if we have a rule “no edge enters the <em>source</em>”. But, this formula covers only “residual networks”.</p>

<p>To solve this problem we use Ford-Fulkerson method. This method iteratively increases overall value of flow and on each iteration increases the flow of the edges of some path from $s$ to $t$ as much as possible:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function ford-fulkerson(G, s, t):
    let flow be 0
    let G_f be the residual network of G
    
    while there exists a path P in Gf:
        let min_res_cap be the minimum residual capacity in P
        augment edges of P by min_res_cap
        increment flow by min_res_cap
    end
    
    return flow
</code></pre></div></div>

<h3 id="residual-networks">Residual networks</h3>

<p>The residual network consists of edges with capacities that represent how we can change the flow on edge of graph g. the residual network is denoted as $g_f$. Some edges of the flow network does not use all the capacity of the edge. So, it can admit more flow: capacity minus flow. We place that edge into $g_f$ with “residual capacity” of $c_f(u,v) = c(u,v) - f(u,v)$. those edges whose flow equals their capacity are not included in $g_f$. however, the residual network can contain edges that does not exist in original graph. more formally, the <strong>residual capacity</strong> defined as follows:
<script type="math/tex">% <![CDATA[
c_f(u, v) = \begin{cases} c(u, v) - f(u, v) & \text{if (u, v) $\in$ e} \\
                            f(u, v) & \text{if(v, u) $\in$ e} \\
                            0 & \text{otherwise}
              \end{cases} %]]></script></p>

<p>we choose a path from residual network and then augment that path with flow $f$. the augmented flow is denoted as $f \uparrow f$ and its definition is previous flow plus the new flow minus going back flow. we find the minimum flow in the residual path and send it to the path. this avoid getting going back flows. the intuition behind this  definition as follows:</p>

<blockquote>
  <p>We increase the flow on $(u, v)$ by $f’(u, v)$ but decrease it by $f’(v, u)$ because pushing flow on the reverse edge in the residual network signifies decreasing the flow in the original network. pushing flow on the reverse edge in the residual network is also known as cancellation. for example, if we send 5 crates of hockey pucks from $u$ to $v$ and send 2 crates from $v$ to $u$, we could equivalently (from the perspective of the final result) just send 3 creates from $u$ to $v$ and none from $v$ to $u$. Cancellation of this type is crucial for any maximum-flow algorithm</p>
</blockquote>

<p>The path from $s$ to $t$ in the residual network is called <strong>augmenting path</strong>. we can increase the flow of edge $(u, v)$ of an aughmenting path by up to $c_f(u, v)$. the maximum amount by which we can increase the flow of edges in the path is called a <strong>residual capacity</strong> and it is defined as: $c_f(p) = \min{ c_f(u, v): (u, v) \text{ is on } p }$</p>

<p><strong>Lemma:</strong> Let $G = (V, E)$ be a flow network with source $s$ and sink $t$,and let $f$ be a flow in $G$. Let $G_f$ be the residual network of $G$ induced by $f$,and let $f’$ be a flow in $G_f$. Then the function $f \uparrow f’$ defined in equation (26.4) is a flow in $G$ with value $\vert f \uparrow f’ \vert = \vert f \vert + \vert f \vert + \vert f’ \vert$.</p>

<h3 id="cuts-of-flow-networks">Cuts of flow networks</h3>

<p>we get a maximum flow continously augmenting the flow along augmenting paths until there are no paths left from $s$ to $t$. the problem is how do we verify the maximum flow. we need techniques for bounding the size of maxflow. the basic idea is to find a <strong>bottleneck</strong> for the flow and all flow needs to cross the bottleneck.
a minimum cut of a network is a cut whose capacity is minimum over all cuts of the network.</p>

<p>the max-flow min-cut theorem tells us that a flow is maximum if and only if its residual network contains no augmenting path.</p>

<p>firstly, a cut $(s, t)$ of flow $g = (v, e)$ is partition of $v$ into $s$ and $t = v - s$. simply, the first half of the cut contains all the sources of $g$. the net-flow $f(s,t)$ is defined as <script type="math/tex">f(s,t) = \sum_{u \in s} \sum_{v \in t} f(u, v) - \sum_{u \in s} \sum_{v \in t} f(v, u)</script> That is the sum of flow going to cut $s$ minus sum of flows going back from $t$ into $s$.</p>

<p>The capacity of cut is $c(s, t) = \sum_{u \in s} \sum_{v \in t} c(u, v)$. The <strong>minimum cut</strong> of network is a cut whose capacity in minimum over all cuts of the network.</p>

<h3 id="code">Code</h3>

<p>The implementation of this algorithm is written in C++</p>

<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using std::min;
using std::numeric_limits;
using std::stack;
using std::vector;

struct Edge {
  int from, to, capacity, flow;
};

class FlowGraph {
private:
  vector&lt;Edge&gt; edges;
  vector&lt;vector&lt;size_t&gt;&gt; graph;

public:
  explicit FlowGraph(size_t n) : graph(n) {}

  void add_edge(int from, int to, int capacity) {
    // We first append a forward edge and then a backward edge.
    // All forward edges are stored at EVEN indices (starting from 0),
    // whereas backward edges are stored at ODD indices in the list edges.
    Edge forward_edge = {from, to, capacity, 0};
    Edge backward_edge = {to, from, 0, 0};

    graph[from].push_back(edges.size());
    edges.push_back(forward_edge);

    graph[to].push_back(edges.size());
    edges.push_back(backward_edge);
  }

  size_t size() const { return graph.size(); }

  const vector&lt;size_t&gt; &amp;get_ids(int from) const {
    return graph[from];
  }

  const Edge &amp;get_edge(size_t id) const {
    return edges[id];
  }

  void add_flow(size_t id, int flow) {
    /*
     * To get a backward edge for a true forward edge (i.e id is even), we
     * should get id + 1 due to the described above scheme. On the other hand,
     * when we have to get a "backward" edge for a backward edge (i.e. get a
     * forward edge for backward - id is odd), id - 1 should be taken.
     *
     * It turns out that id ^ 1 works for both cases. Think this through!
     */
    edges[id].flow += flow;
    edges[id ^ 1].flow -= flow;
  }
};

FlowGraph read_data() {
  int vertex_count, edge_count;
  std::cin &gt;&gt; vertex_count &gt;&gt; edge_count;
  FlowGraph graph(vertex_count);
  for (int i = 0; i &lt; edge_count; ++i) {
    int u, v, capacity;
    std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; capacity;
    graph.add_edge(u - 1, v - 1, capacity);
  }
  return graph;
}

vector&lt;int&gt; dfs(FlowGraph &amp;graph, int from, int to) {
  stack&lt;int&gt; s;
  s.push(from);
  vector&lt;bool&gt; used(graph.size());
  vector&lt;int&gt; parent(graph.size(), -1);

  while (!s.empty()) {
    int u = s.top();
    s.pop();
    used[u] = true;

    if(u == to) {
    	break;
    }

    for (auto v : graph.get_ids(u)) {
      const Edge&amp; edge = graph.get_edge(v);
      if ((edge.capacity - edge.flow) &lt;= 0) {
        continue;
      }

      if (!used[edge.to]) {
      	s.push(edge.to);
        parent[edge.to] = v;
      }
    }
  }


  vector&lt;int&gt; path;
  while(to != from) {
    auto id = parent[to];
    if(id == -1) {
      return vector&lt;int&gt;();
    }
    path.push_back(id);
    to = graph.get_edge(id).from;
  }

  return path;
}

int max_flow(FlowGraph &amp;graph, int from, int to) {
  int flow = 0;

  while (true) {
    auto path = dfs(graph, from, to);
    if (path.empty()) {
      break;
    }

    int cf = numeric_limits&lt;int&gt;::max();

    for (auto &amp;edge_id: path) {
      auto edge = graph.get_edge(edge_id);
      cf = min(cf, edge.capacity - edge.flow);
    }

    flow += cf;

    for(auto &amp;edge : path) {
      graph.add_flow(edge, cf);
    }
  }

  return flow;
}

int main() {
  FlowGraph graph = read_data();

  std::cout &lt;&lt; max_flow(graph, 0, graph.size() - 1) &lt;&lt; "\n";
  return 0;
}

</code></pre>

<h3 id="analysis-of-ford-fulkerson-algorithm">Analysis of Ford-Fulkerson algorithm</h3>

<h3 id="better-aproach-with-edmonds-karp-algorithm">Better aproach with Edmonds-Karp algorithm</h3>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Maksadbek&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Maksadbek&#39;s blog</li><li><a class="u-email" href="mailto:a.maksadbek@gmail.com">a.maksadbek@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/maksadbek"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">maksadbek</span></a></li><li><a href="https://www.twitter.com/sayhellotomax"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">sayhellotomax</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal blog, articles are mostly about the things that I did not understand before, that is why I explored them and wrote an article.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
