<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Maximum-flow problem - Maksadbek</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="/maximum-flow-problem.html">

        <meta name="author" content="maksadbek" />
        <meta name="description" content="Flow and flow networks Flow network is a graph \(G = (V, E)\) with the following features: Each edge has a nonnegative capacity - \(c_e\) There is a single node considered as source of the flow The is a single node considered as sink that absorbs the flow. No edge enters the …" />

        <meta property="og:site_name" content="Maksadbek" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Maximum-flow problem"/>
        <meta property="og:url" content="/maximum-flow-problem.html"/>
        <meta property="og:description" content="Flow and flow networks Flow network is a graph \(G = (V, E)\) with the following features: Each edge has a nonnegative capacity - \(c_e\) There is a single node considered as source of the flow The is a single node considered as sink that absorbs the flow. No edge enters the …"/>
        <meta property="article:published_time" content="2019-04-23" />
            <meta property="article:section" content="misc" />
            <meta property="article:author" content="maksadbek" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/css/pygments/emacs.css" rel="stylesheet">
    <link rel="stylesheet" href="/theme/css/style.css" type="text/css"/>
        <link href="/static/css/custom.css" rel="stylesheet">



</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="/" class="navbar-brand">
Maksadbek            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="/pages/about.html">
                             About
                          </a></li>
                         <li><a href="/pages/resume.html">
                             Resume
                          </a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">

              <li><a href="/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>

            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>Maximum-flow problem</h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2019-04-23T16:46:40+03:00"> Tue 23 April 2019</time>
    </span>





    
</footer><!-- /.post-info -->                    </div>
                </div>
                <div class="section" id="flow-and-flow-networks">
<h2>Flow and flow networks</h2>
<p><strong>Flow network</strong> is a graph <span class="math">\(G = (V, E)\)</span> with the following
features:</p>
<ul class="simple">
<li>Each edge has a nonnegative capacity - <span class="math">\(c_e\)</span></li>
<li>There is a single node considered as <em>source</em> of the flow</li>
<li>The is a single node considered as <em>sink</em> that absorbs the flow.</li>
<li>No edge enters the <em>source</em> and no edges leaves <em>sink</em></li>
<li>There is at least one edge incident to each node.</li>
</ul>
<p>The nodes other than <em>source</em> and <em>sink</em> are called <em>internal</em> nodes.</p>
<p><strong>Flow</strong> is a function <span class="math">\(f\)</span> that maps each edge <span class="math">\(e\)</span> to a
nonnegative real number: <span class="math">\(f: e \to r\)</span>; the value of <span class="math">\(f(e)\)</span>
represents the amount of flow carried by edge <span class="math">\(e\)</span>. a flow
<span class="math">\(f\)</span> must satisfy the following two properties:</p>
<p>The flow from <span class="math">\(u\)</span> to <span class="math">\(v\)</span> is a nonnegative and defined as
<span class="math">\(f(u, v)\)</span> and value of a flow <span class="math">\(f\)</span> is denoted with
<span class="math">\(\vert f \vert\)</span> and defined as:
<span class="math">\(\vert f \vert = \sum_{v \in v} f(s, v) - \sum_{v \in v} f(v, s)\)</span>.
That is, the total from out of source to adjacent vertexes minus the
total flow from adjacent vertexes into source. yes, this can happen,
where source node has both incoming and outgoing edges.</p>
<p>Even if we have a rule &quot;no edge enters the <em>source</em>&quot;. But, this formula
covers only &quot;residual networks&quot;.</p>
<p>To solve this problem we use Ford-Fulkerson method. This method
iteratively increases overall value of flow and on each iteration
increases the flow of the edges of some path from <span class="math">\(s\)</span> to <span class="math">\(t\)</span>
as much as possible:</p>
<pre class="literal-block">
function ford-fulkerson(G, s, t):
    let flow be 0
    let G_f be the residual network of G

    while there exists a path P in Gf:
        let min_res_cap be the minimum residual capacity in P
        augment edges of P by min_res_cap
        increment flow by min_res_cap
    end

    return flow
end
</pre>
</div>
<div class="section" id="residual-networks">
<h2>Residual networks</h2>
<p>The residual network consists of edges with capacities that represent
how we can change the flow on edge of graph g. the residual network is
denoted as <span class="math">\(g_f\)</span>. Some edges of the flow network does not use all
the capacity of the edge. So, it can admit more flow: capacity minus
flow. We place that edge into <span class="math">\(g_f\)</span> with &quot;residual capacity&quot; of
<span class="math">\(c_f(u,v) = c(u,v) - f(u,v)\)</span>. those edges whose flow equals their
capacity are not included in <span class="math">\(g_f\)</span>. however, the residual network
can contain edges that does not exist in original graph. more formally,
the <strong>residual capacity</strong> defined as follows:</p>
<div class="math">
\begin{equation*}
c_f(u, v) =
\begin{cases}
c(u, v) - f(u, v), &amp; \text{if (u, v) $\in$ e} \\
f(u, v), &amp; \text{if(v, u) $\in$ e} \ 0 &amp; \text{otherwise}
\end{cases}
\end{equation*}
</div>
<p>we choose a path from residual network and then augment that path with
flow <span class="math">\(f\)</span>. the augmented flow is denoted as <span class="math">\(f \uparrow f\)</span>
and its definition is previous flow plus the new flow minus going back
flow. we find the minimum flow in the residual path and send it to the
path. this avoid getting going back flows. the intuition behind this
definition as follows:</p>
<blockquote>
We increase the flow on <span class="math">\((u, v)\)</span> by <span class="math">\(f'(u, v)\)</span> but
decrease it by <span class="math">\(f'(v, u)\)</span> because pushing flow on the reverse
edge in the residual network signifies decreasing the flow in the
original network. pushing flow on the reverse edge in the residual
network is also known as cancellation. for example, if we send 5
crates of hockey pucks from <span class="math">\(u\)</span> to <span class="math">\(v\)</span> and send 2 crates
from <span class="math">\(v\)</span> to <span class="math">\(u\)</span>, we could equivalently (from the
perspective of the final result) just send 3 creates from <span class="math">\(u\)</span>
to <span class="math">\(v\)</span> and none from <span class="math">\(v\)</span> to <span class="math">\(u\)</span>. Cancellation of
this type is crucial for any maximum-flow algorithm</blockquote>
<p>The path from <span class="math">\(s\)</span> to <span class="math">\(t\)</span> in the residual network is called
<strong>augmenting path</strong>. we can increase the flow of edge <span class="math">\((u, v)\)</span> of
an aughmenting path by up to <span class="math">\(c_f(u, v)\)</span>. the maximum amount by
which we can increase the flow of edges in the path is called a
<strong>residual capacity</strong> and it is defined as:
<span class="math">\(c_f(p) = \min\{ c_f(u, v): (u, v) \text{ is on } p \}\)</span></p>
<p><strong>Lemma:</strong> Let <span class="math">\(G = (V, E)\)</span> be a flow network with source
<span class="math">\(s\)</span> and sink <span class="math">\(t\)</span>,and let <span class="math">\(f\)</span> be a flow in <span class="math">\(G\)</span>.
Let <span class="math">\(G_f\)</span> be the residual network of <span class="math">\(G\)</span> induced by
<span class="math">\(f\)</span>,and let <span class="math">\(f'\)</span> be a flow in <span class="math">\(G_f\)</span>. Then the function
<span class="math">\(f \uparrow f'\)</span> defined in equation (26.4) is a flow in <span class="math">\(G\)</span>
with value
<span class="math">\(\vert f \uparrow f' \vert = \vert f \vert + \vert f \vert + \vert f' \vert\)</span>.</p>
<p>This lemma is true, don't ask me why. Look at CLRS for the proof.</p>
</div>
<div class="section" id="cuts-of-flow-networks">
<h2>Cuts of flow networks</h2>
<p>we get a maximum flow continously augmenting the flow along augmenting
paths until there are no paths left from <span class="math">\(s\)</span> to <span class="math">\(t\)</span>. the
problem is how do we verify the maximum flow. we need techniques for
bounding the size of maxflow. the basic idea is to find a <strong>bottleneck</strong>
for the flow and all flow needs to cross the bottleneck. a minimum cut
of a network is a cut whose capacity is minimum over all cuts of the
network.</p>
<p>the max-flow min-cut theorem tells us that a flow is maximum if and only
if its residual network contains no augmenting path.</p>
<p>firstly, a cut <span class="math">\((s, t)\)</span> of flow <span class="math">\(g = (v, e)\)</span> is partition of
<span class="math">\(v\)</span> into <span class="math">\(s\)</span> and <span class="math">\(t = v - s\)</span>. simply, the first half
of the cut contains all the sources of <span class="math">\(g\)</span>. the net-flow
<span class="math">\(f(s,t)\)</span> is defined as</p>
<div class="math">
\begin{equation*}
f(s,t) = \sum_{u \in s} \sum_{v \in t} f(u, v) - \sum_{u \in s} \sum_{v \in t} f(v, u)
\end{equation*}
</div>
<p>That is the sum of flow going to cut <span class="math">\(s\)</span> minus sum of flows going
back from <span class="math">\(t\)</span> into <span class="math">\(s\)</span>.</p>
<p>The capacity of cut is
<span class="math">\(c(s, t) = \sum_{u \in s} \sum_{v \in t} c(u, v)\)</span>. The <strong>minimum
cut</strong> of network is a cut whose capacity in minimum over all cuts of the
network.</p>
</div>
<div class="section" id="code">
<h2>Code</h2>
<p>The implementation of this algorithm is written in C++</p>
<pre class="code C++ literal-block">
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">flow</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FlowGraph</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">FlowGraph</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We first append a forward edge and then a backward edge.
</span>        <span class="c1">// All forward edges are stored at EVEN indices (starting from 0),
</span>        <span class="c1">// whereas backward edges are stored at ODD indices in the list edges.
</span>        <span class="n">Edge</span> <span class="n">forward_edge</span> <span class="o">=</span> <span class="p">{</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">Edge</span> <span class="n">backward_edge</span> <span class="o">=</span> <span class="p">{</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

        <span class="n">graph</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">forward_edge</span><span class="p">);</span>

        <span class="n">graph</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">backward_edge</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">get_ids</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">get_edge</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_flow</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">)</span> <span class="p">{</span>
       <span class="cm">/*
        * To get a backward edge for a true forward edge (i.e id is even), we
        * should get id + 1 due to the described above scheme. On the other hand,
        * when we have to get a &quot;backward&quot; edge for a backward edge (i.e. get a
        * forward edge for backward - id is odd), id - 1 should be taken.
        *
        * It turns out that id ^ 1 works for both cases. Think this through!
        */</span>

        <span class="n">edges</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">flow</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">[</span><span class="n">id</span> <span class="o">^</span> <span class="mi">1</span><span class="p">].</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">flow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">FlowGraph</span> <span class="nf">read_data</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">vertex_count</span><span class="p">,</span> <span class="n">edge_count</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">vertex_count</span> <span class="o">&gt;&gt;</span> <span class="n">edge_count</span><span class="p">;</span>

    <span class="n">FlowGraph</span> <span class="n">graph</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edge_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">graph</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">capacity</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">FlowGraph</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">used</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_ids</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">edge</span><span class="p">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">flow</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">to</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">to</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="n">to</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">from</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">max_flow</span><span class="p">(</span><span class="n">FlowGraph</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">path</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">cf</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">edge_id</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">edge_id</span><span class="p">);</span>
            <span class="n">cf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">edge</span><span class="p">.</span><span class="n">flow</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">flow</span> <span class="o">+=</span> <span class="n">cf</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">edge</span> <span class="p">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">graph</span><span class="p">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">cf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">FlowGraph</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max_flow</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>&lt;TBA&gt;Analysis of Ford-Fulkerson algorithm&lt;/TBA&gt;</p>
<p>&lt;TBA&gt;Better aproach with Edmonds-Karp algorithm&lt;/TBA&gt;</p>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2021 maksadbek                <p><small>  <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.en"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by/4.0/80x15.png" /></a>
    Content
  licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.en">Creative Commons Attribution 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="/theme/js/respond.min.js"></script>




</body>
</html>